//@version=5
// Market Readiness Indicator [MRI]
// Version: v1.0
// Status: Locked / Stable Release
// Date: 2025-12-28
// Note: This version is frozen. Future changes must be additive only.
indicator("Market Readiness Indicator [MRI]", shorttitle="MRI", overlay=true, max_boxes_count=50, max_lines_count=50, max_labels_count=50)

// ==========================================
// 1. INPUTS
// ==========================================
show_bg = input.bool(true, "Show Background Tint", group="Visuals")
// V2 Structure replaces V1
show_liquidity = input.bool(true, "Show Institutional S/R Lines", group="Visuals")

enable_pullback_triggers = input.bool(false, "Enable Pullback Triggers", group="Triggers (Optional)")
enable_ema_reclaim = input.bool(false, "Trigger: EMA Reclaim", group="Triggers (Optional)")
enable_structure_break = input.bool(false, "Trigger: Structure Break", group="Triggers (Optional)")

enable_strict_gating = input.bool(false, "Enable Strict Pullback Gating", group="Risk Management")

// ==========================================
// 2. HELPER FUNCTIONS
// ==========================================
// Standard Normalize
normalize(val, min, max) =>
    (math.max(min, math.min(val, max)) - min) / (max - min) * 100

// ==========================================
// 3. MARKET DIMENSIONS
// ==========================================

// --- A. Direction (Bias) ---
// EMA 50 Baseline + Slope
baseline_len = 50
baseline = ta.ema(close, baseline_len)
// Slope over 5 bars for faster reaction than 10
slope = (baseline - baseline[5]) / baseline[5]
// Price relative to baseline
bias_bullish = close > baseline and slope > 0
bias_bearish = close < baseline and slope < 0

// --- B. Quality (Efficiency) ---
// Kaufman Efficiency Ratio (ER)
len_er = 14 // Standard shorter length for reaction
change = math.abs(close - close[len_er])
vol_sum = math.sum(math.abs(close - close[1]), len_er)
er = vol_sum != 0 ? change / vol_sum : 0
// Quality Thresholds
// > 0.30 = Trending/High Quality
// < 0.15 = Chop/No Edge
is_chop = er < 0.15
is_quality = er >= 0.30
// "Okay" quality is between 0.15 and 0.30

// --- C. Extension (Exhaustion) ---
// Bollinger Band Width limit
// If price > 2.2 SD, it's extended
sd = ta.stdev(close, 50)
upper_dev = baseline + (2.2 * sd)
lower_dev = baseline - (2.2 * sd)
is_extended_long = close > upper_dev
is_extended_short = close < lower_dev

// --- D. Volatility Risk (Avoid) ---
// Detect extreme volatility spikes (Flash crash / Pump)
atr = ta.atr(14)
atr_avg = ta.sma(atr, 50)
// If ATR is 2.5x the average, it's high risk
is_vol_spike = atr > (atr_avg * 2.5)

// ==========================================
// 4. DECISION ENGINE (5 STATES)
// ==========================================
// States:
// 2  = LONG - Trend Active
// -2 = SHORT - Trend Active
// 1  = WAIT - Pullback / Reset
// 0  = NO EDGE - Chop
// -9 = AVOID - High Risk

int state = 0 

// Priority Logic (Safety First)

if is_vol_spike
    state := -9 // AVOID
else
    // Bias Logic First
    if bias_bullish
        if is_quality and not is_extended_long
            state := 2 // LONG (Good Quality + Not Extended)
        else
            state := 1 // WAIT (Extended OR Low Quality, but Bias holds)
    else if bias_bearish
        if is_quality and not is_extended_short
            state := -2 // SHORT (Good Quality + Not Extended)
        else
            state := 1 // WAIT (Extended OR Low Quality, but Bias holds)
    else
        // Bias is strictly neutral (Flat or conflicting)
        state := 0 // NO EDGE

// ==========================================
// 5. TRANSITION RULES & CONFIRMATION
// ==========================================
// Rule 1: Do NOT flip directly from LONG -> SHORT or SHORT -> LONG
var int prev_major_state = 0 // Track last active trend (2 or -2)

if (state == 2 and prev_major_state == -2) or (state == -2 and prev_major_state == 2)
    state := 0 // Force NO EDGE transit

// Rule 2: Graceful Degradation
// If dropping from trend directly to NO EDGE, force WAIT
if state == 0
    if state[1] == 2 or state[1] == -2
        state := 1

// Update history
if state == 2 or state == -2
    prev_major_state := state

// Rule 3: 2-Bar Confirmation (Stability Patch)
// A state change must persist for 2 bars to be accepted
var int confirmed_state = 0

// If current calculated state matches previous bar's calculated state, accept it
// Otherwise, hold the old confirmed state
if state == state[1]
    confirmed_state := state

// ==========================================
// 6. WAIT STATE QUALITY (PULLBACK SCORE)
// ==========================================
// Calculate Score components regardless of state, but use only when WAIT
float pb_score = 0.0

// A. Trend Intact (Checked by state==1 implying bias exists)
// B. Pullback Depth Scoring
float depth = 0.0
if bias_bullish
    depth := (baseline - close) / atr
else if bias_bearish
    depth := (close - baseline) / atr
else
    depth := 0.0
depth := math.max(0, depth) // Clamp to >= 0

float score_depth = 0.0
if depth <= 0.8
    score_depth := 40
else if depth <= 1.5
    score_depth := 20
else
    score_depth := 0

// C. Volatility Scoring
float vol_ratio = atr / atr_avg
float score_vol = 0.0
if vol_ratio <= 1.2
    score_vol := 30
else if vol_ratio <= 1.6
    score_vol := 15
else
    score_vol := 0

// D. Efficiency Scoring
float score_er = 0.0
if er >= 0.25
    score_er := 30
else if er >= 0.18
    score_er := 15
else
    score_er := 0

pb_score := score_depth + score_vol + score_er
bool is_wait_good = pb_score >= 60

// ==========================================
// 7. PULLBACK OPPORTUNITY GATING (STRICT)
// ==========================================
// Tracks if "Pullback Action" has already been taken for this trend leg.
var bool pb_opportunity_used = false

// Reset Rule: If trend resumes (LONG/SHORT), reset the opportunity latch
if confirmed_state == 2 or confirmed_state == -2
    pb_opportunity_used := false

// Evaluation Rule:
// If WAIT-GOOD and latch is false -> ACTIONABLE (and flip latch to true)
// If WAIT-GOOD and latch is true  -> COOLDOWN
bool is_actionable = false
if enable_strict_gating
    if confirmed_state == 1 and is_wait_good
        if not pb_opportunity_used
            is_actionable := true
            pb_opportunity_used := true // Latch it
        else
            is_actionable := false // Already used
else
    // If gating disabled, all GOOD waits are actionable
    is_actionable := true


// ==========================================
// 8. INSTITUTIONAL LIQUIDITY ZONES (V2)
// ==========================================
// Replaces simple lines with Reacting Liquidity Zones
// ------------------------------------------

// --- Types ---
type Zone
    float price   // Center price (or pivot price)
    float top     // Top of zone [Internal Use Only for clustering]
    float bot     // Bottom of zone [Internal Use Only for clustering]
    int count     // Reaction count
    int last_bar  // Bar index of last reaction
    bool is_sup   // True = Support, False = Resistance

// --- Globals ---
var zone_arr = array.new<Zone>(0)

// --- Settings ---
// Hardcoded per spec to "Professional Grade" defaults
f_len = 2          // Fractal length
z_cluster = 0.75   // Multiplier of ATR for clustering
z_height_min = 0.5 // Min height ATR multiplier (Still used for logic, invisible)
z_invalid = 1.0    // Invalidation ATR multiplier (close > top + this)
// VISUAL FILTER: Only draw if within this distance
vis_dist_atr = 6.0 

// --- 1. Structure Detection (Fractals) ---
ph = ta.pivothigh(high, f_len, f_len)
pl = ta.pivotlow(low, f_len, f_len)

// --- 2. Zone Logic Functions ---

// Function to check reaction or create new
update_zones(float pivot, bool is_s, float atr_val) =>
    bool found = false
    // Cluster check
    if array.size(zone_arr) > 0
        for i = 0 to array.size(zone_arr) - 1
            Zone z = array.get(zone_arr, i)
            // Match Direction
            if z.is_sup == is_s
                // Match Distance (within 0.75 ATR)
                // Use the zone's center price for distance check
                if math.abs(pivot - z.price) <= (atr_val * z_cluster)
                    // Valid Reaction? (Separated by time: at least f_len bars)
                    if (bar_index - z.last_bar) >= f_len
                        // Update Zone
                        z.count += 1
                        z.last_bar := bar_index
                        // Expand geometry slightly to encompass new pivot, but keep anchored
                        z.top := math.max(z.top, pivot)
                        z.bot := math.min(z.bot, pivot)
                        // Ensure min height
                        float mid = (z.top + z.bot) / 2
                        float min_h = atr_val * z_height_min
                        if (z.top - z.bot) < min_h
                            z.top := mid + min_h/2
                            z.bot := mid - min_h/2
                        
                        found := true
                        break
    
    // Create new if not found
    if not found
        // Initial geometry
        float top_new = pivot
        float bot_new = pivot
        // Apply min height centered
        float min_h_new = atr_val * z_height_min
        top_new := pivot + min_h_new/2
        bot_new := pivot - min_h_new/2
        
        Zone new_z = Zone.new(pivot, top_new, bot_new, 1, bar_index, is_s)
        array.push(zone_arr, new_z)

// --- 3. Execution (On Fractal Confirm) ---
// Fractals are confirmed 'f_len' bars ago, but we process them now using the stored value
// We check if 'ph' is not NaN. ph is the High of the pivot candle.
if not na(ph)
    update_zones(ph, false, atr)
if not na(pl)
    update_zones(pl, true, atr)

// --- 4. Invalidation & Cleanup ---
// Remove zones if broken decisively
if array.size(zone_arr) > 0
    // Loop backwards to remove safely
    for i = array.size(zone_arr) - 1 to 0
        Zone z = array.get(zone_arr, i)
        
        bool kill = false
        float thresh = atr * z_invalid
        
        if z.is_sup // Support
            // Broken if Close < Bottom - 1.0 ATR
            if close < (z.bot - thresh)
                kill := true
        else // Resistance
            // Broken if Close > Top + 1.0 ATR
            if close > (z.top + thresh)
                kill := true
        
        if kill
            // Just remove from array
            array.remove(zone_arr, i)

// --- 5. Visualization Management ---

type ZDist
    int index
    float dist

// Persistent handles for visual lines
var line vis_sup_line = na
var line vis_res_line = na
// Persistent handles for visual labels
var label vis_sup_lbl = na
var label vis_res_lbl = na

// MAIN VISUALIZATION BLOCK (Inlined for reliability)
if barstate.islast
    // Cleanup previous frame
    line.delete(vis_sup_line)
    line.delete(vis_res_line)
    label.delete(vis_sup_lbl)
    label.delete(vis_res_lbl)
    
    // Temp sorting arrays
    var dist_sup_temp = array.new<ZDist>(0)
    var dist_res_temp = array.new<ZDist>(0)
    array.clear(dist_sup_temp)
    array.clear(dist_res_temp)
    
    // 5a. Filter and Measure Distance
    if array.size(zone_arr) > 0
        float prox_limit = atr * vis_dist_atr // 6x ATR limit

        for i = 0 to array.size(zone_arr) - 1
            Zone z = array.get(zone_arr, i)
            
            if z.count >= 3 // VALIDATION RULE
                // Absolute distance check for proximity filter
                float abs_dist = math.abs(close - z.price)
                
                // STRICT PROXIMITY FILTER
                if abs_dist <= prox_limit
                    if z.is_sup
                        if close > z.bot // Must be below current price (mostly)
                            array.push(dist_sup_temp, ZDist.new(i, abs_dist))
                    else
                        if close < z.top // Must be above current price
                            array.push(dist_res_temp, ZDist.new(i, abs_dist))

    // 5b. Find Winners (Min Distance)
    // Support Winner
    int best_sup_idx = -1
    float min_sup_d = 9999999.9
    if array.size(dist_sup_temp) > 0
        for k = 0 to array.size(dist_sup_temp) - 1
            ZDist item = array.get(dist_sup_temp, k)
            if item.dist < min_sup_d
                min_sup_d := item.dist
                best_sup_idx := k
    
    // Resistance Winner
    int best_res_idx = -1
    float min_res_d = 9999999.9
    if array.size(dist_res_temp) > 0
        for k = 0 to array.size(dist_res_temp) - 1
            ZDist item = array.get(dist_res_temp, k)
            if item.dist < min_res_d
                min_res_d := item.dist
                best_res_idx := k
                
    // 5c. Visibility Checks
    // Is MRI Active? (LONG, SHORT, WAIT-GOOD)
    bool is_active = confirmed_state == 2 or confirmed_state == -2 or (confirmed_state == 1 and is_wait_good)
    
    if show_liquidity and is_active
        // DRAW SUPPORT
        if best_sup_idx != -1
            ZDist w_sup = array.get(dist_sup_temp, best_sup_idx)
            Zone z_sup = array.get(zone_arr, w_sup.index)
            
            // Label
            // 1. Compute % Distance (Signed)
            // If Close > Price, positive. If Close < Price, negative.
            float sup_dist_signed = (close - z_sup.price) / z_sup.price * 100
            
            // 2. Classify State
            string t_sup_state = ""
            color c_sup_state = color.green
            string s_sup_style = line.style_solid
            
            if sup_dist_signed >= 0.3
                // HOLDING
                t_sup_state := "Holding Above Support"
                c_sup_state := color.green
                s_sup_style := line.style_solid
            else if math.abs(sup_dist_signed) < 0.3
                // TESTING
                t_sup_state := "Support Under Test\nReclaim Required"
                c_sup_state := color.orange
                s_sup_style := line.style_dashed
            else
                // BROKEN ( <= -0.3 )
                t_sup_state := "Support Broken\nWatch Next Demand Zone"
                c_sup_state := color.gray
                s_sup_style := line.style_dashed
            
            // 3. Draw Line with Dynamic Style
            vis_sup_line := line.new(bar_index - 5, z_sup.price, bar_index + 25, z_sup.price, color=color.new(c_sup_state, 0), width=2, style=s_sup_style)
            
            // 4. Construct Label
            float sup_dist_pct = math.abs((z_sup.price - close) / close) * 100
            string s_dir = z_sup.price < close ? "Below" : "Above"
            string t_sup = "Institutional Demand (Support)\n@ " + str.tostring(z_sup.price, "#.##") + "\n" + str.tostring(sup_dist_pct, "#.#") + "% " + s_dir + " Current Price\n" + t_sup_state
            vis_sup_lbl := label.new(bar_index + 25, z_sup.price, text=t_sup, style=label.style_label_left, color=color.new(c_sup_state, 20), textcolor=color.white, size=size.normal)
            
        // DRAW RESISTANCE
        if best_res_idx != -1
            ZDist w_res = array.get(dist_res_temp, best_res_idx)
            Zone z_res = array.get(zone_arr, w_res.index)
            
            vis_res_line := line.new(bar_index - 5, z_res.price, bar_index + 25, z_res.price, color=color.new(color.red, 0), width=2, style=line.style_solid)
            
            // Label
            float res_dist_pct = math.abs((z_res.price - close) / close) * 100
            string r_dir = z_res.price > close ? "Above" : "Below"
            string t_res = "Institutional Supply (Resistance)\n@ " + str.tostring(z_res.price, "#.##") + "\n" + str.tostring(res_dist_pct, "#.#") + "% " + r_dir + " Current Price\nActive Overhead Supply"
            vis_res_lbl := label.new(bar_index + 25, z_res.price, text=t_res, style=label.style_label_left, color=color.new(color.red, 20), textcolor=color.white, size=size.normal)


// ==========================================
// 9. PULLBACK TRIGGERS (OPTIONAL)
// ==========================================
var string trigger_msg = ""
bool trig_ema = false
bool trig_struct = false

// Calculate indicators GLOBALLY to preserve historical consistency
ema21 = ta.ema(close, 21)
high_5 = ta.highest(high, 5)[1]
low_5 = ta.lowest(low, 5)[1]

if enable_pullback_triggers and confirmed_state == 1 and is_wait_good
    // A. EMA Reclaim
    if enable_ema_reclaim
        if bias_bullish and ta.crossover(close, ema21)
            trig_ema := true
        if bias_bearish and ta.crossunder(close, ema21)
            trig_ema := true
            
    // B. Structure Break
    if enable_structure_break
        if bias_bullish
            if close > high_5
                trig_struct := true
        if bias_bearish
            if close < low_5
                trig_struct := true

// ==========================================
// 10. VISUALIZATION
// ==========================================

// Colors
c_long  = color.new(#4caf50, 0) // Green
c_short = color.new(#ef5350, 0) // Red
c_wait  = color.new(#ff9800, 0) // Orange (Default BAD)
c_wait_good = color.new(#ffb74d, 0) // Lighter/Green-tinted Orange (Visual Distinction)
c_chop  = color.new(#9e9e9e, 0) // Grey
c_avoid = color.new(#7e57c2, 0) // Purple/Dark

c_bg_long  = color.new(#4caf50, 92)
c_bg_short = color.new(#ef5350, 92)
c_bg_wait  = color.new(#ff9800, 92)      // Standard Orange
c_bg_wait_good = color.new(#81c784, 85) // Subtle Green-Orange mix for GOOD
c_bg_chop  = color.new(#9e9e9e, 94)
c_bg_avoid = color.new(#7e57c2, 90)

// Text & Color Mapping
var string txt = "NO EDGE - Chop"
var color col = c_chop
var color bgc = c_bg_chop
var string sub_txt = ""

if confirmed_state == 2
    txt := "LONG – Trend Active"
    col := c_long
    bgc := c_bg_long
    sub_txt := "This indicator defines when to trade, not how to enter."

else if confirmed_state == -2
    txt := "SHORT – Trend Active"
    col := c_short
    bgc := c_bg_short
    sub_txt := "This indicator defines when to trade, not how to enter."

else if confirmed_state == 1
    // Split logic for WAIT
    if is_wait_good
        txt := "WAIT – Market Conditions Favorable"
        col := c_wait
        bgc := c_bg_wait_good
        
        // Base Subtitle
        sub_txt := "PullbackScore: " + str.tostring(pb_score, "#") + "/100"
        
        // Append Actionable vs Cooldown status if enabled
        if enable_strict_gating
            if is_actionable
                sub_txt := sub_txt + " (ACTIONABLE)"
            else
                sub_txt := sub_txt + " (COOLDOWN)"
        else
            sub_txt := sub_txt + " (Trend & Volatility Stable)\nEntry depends on price location vs Support / Resistance"
        
        // Append Trigger Info if fired
        if trig_ema
            sub_txt := sub_txt + "\nTrigger: EMA Reclaim"
        if trig_struct
            sub_txt := sub_txt + "\nTrigger: Structure Break"
        
    else
        txt := "WAIT – Market Conditions Unstable"
        col := c_wait
        bgc := c_bg_wait
        sub_txt := "PullbackScore: " + str.tostring(pb_score, "#") + "/100 (High Volatility or Weak Trend)\nEntry depends on price location vs Support / Resistance"

else if confirmed_state == -9
    txt := "AVOID – High Risk"
    col := c_avoid
    bgc := c_bg_avoid
    sub_txt := "This indicator defines when to trade, not how to enter."

else
    txt := "NO EDGE – Chop"
    col := c_chop
    bgc := c_bg_chop
    sub_txt := "This indicator defines when to trade, not how to enter."


// TASK: HTF Context & Safeguards
bool is_htf = timeframe.in_seconds(timeframe.period) >= timeframe.in_seconds("1W")
bool data_ok = not na(pb_score) and not na(atr_avg) and not na(er)

if confirmed_state == 1
    // Add Timeframe Context
    string context_txt = is_htf ? "Context: Higher-Timeframe Trend Assessment" : "Context: Short-Term Tradeability"
    sub_txt := sub_txt + "\n" + context_txt
    
    // Add Alignment Advice
    if is_htf and not is_wait_good
        sub_txt := sub_txt + "\nLower timeframes may still offer counter-trend opportunities"
    if not is_htf and is_wait_good
        sub_txt := sub_txt + "\nHigher timeframe trend should be checked for alignment"

if not data_ok
    sub_txt := "Insufficient historical data (Higher TF warm-up)"


// Background
bgcolor(show_bg ? bgc : na, title="State Background")

// Table Panel
var table panel = table.new(position.top_right, 1, 2, border_width=0)

if barstate.islast
    // Statistic Subtext
    // Row 0: State
    table.cell(panel, 0, 0, txt, bgcolor=col, text_color=color.white, text_size=size.small, width=16)
    // Row 1: Subtitle
    table.cell(panel, 0, 1, sub_txt, bgcolor=color.new(color.white, 100), text_color=color.gray, text_size=size.tiny)

// Plot Hidden State for alerts to reference
plot(confirmed_state, title="State ID", display=display.none)

// ==========================================
// 11. ALERTS
// ==========================================
// Alert on confirmed state change
alertcondition(confirmed_state != confirmed_state[1], title="State Changed", message="MRI State changed to {{plot_0}}")

// Special Alert: Wait Quality Flip
bool wait_flip = confirmed_state == 1 and (is_wait_good != is_wait_good[1])
bool became_good = wait_flip and is_wait_good
bool became_bad = wait_flip and not is_wait_good

alertcondition(became_good, title="Wait Quality -> GOOD", message="MRI Pullback Quality changed to GOOD")
alertcondition(became_bad, title="Wait Quality -> BAD", message="MRI Pullback Quality changed to BAD")

// Trigger Alerts
alertcondition(trig_ema, title="Pullback Trigger: EMA Reclaim", message="MRI Trigger: EMA Reclaim in WAIT-GOOD")
alertcondition(trig_struct, title="Pullback Trigger: Structure Break", message="MRI Trigger: Structure Break in WAIT-GOOD")
